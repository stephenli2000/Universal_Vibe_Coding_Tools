import os
import sys
import argparse
from pathlib import Path

# --- Configuration ---
ALLOWED_EXTENSIONS = {
    '.py', '.tsx', '.css', '.js', '.conf', '.json',
    '.html', '.yml', '.yaml', '.txt', '.sh', '.md', '.ini', '.ts'
}
CODE_EXTENSIONS = {
    '.py', '.tsx', '.js', '.ts', '.html', '.css', '.sh',
}
PYTHON_EXTENSIONS = {'.py'}
ALLOWED_FILENAMES = {'dockerfile'}
EXCLUDED_FILENAMES = {'package-lock.json', 'yarn.lock', 'pnpm-lock.yaml', 'gmail_token.json', 'gmail_credentials.json'}
EXCLUDED_DIRS = {
    'node_modules', '.git', 'dist', 'build', 'out',
    '.vscode', '__pycache__', '.idea', '.venv'
}

def format_size(size_bytes: int) -> str:
    """Converts a size in bytes to a human-readable string (KB, MB, GB)."""
    if size_bytes == 0:
        return "0 B"
    power = 1024
    n = 0
    power_labels = {0: 'B', 1: 'KB', 2: 'MB', 3: 'GB', 4: 'TB'}
    while size_bytes >= power and n < len(power_labels) - 1:
        size_bytes /= power
        n += 1
    return f"{size_bytes:.2f} {power_labels[n]}" if n > 0 else f"{int(size_bytes)} {power_labels[n]}"

def find_files_to_process(input_dir: Path, code_only: bool, py_only: bool) -> list[tuple[Path, int]]:
    """
    Finds all files in the directory that match the allowlist, are not in the blocklist,
    and sorts them by size in descending order.
    """
    files_with_sizes = []
    print(f"üîç Searching for files in '{input_dir}'...")
    print(f"   (Ignoring directories: {', '.join(EXCLUDED_DIRS)})")

    if py_only:
        extensions_to_check = PYTHON_EXTENSIONS
        print("   (Filtering for Python files only)")
    elif code_only:
        extensions_to_check = CODE_EXTENSIONS
        print("   (Filtering for code files only)")
    else:
        extensions_to_check = ALLOWED_EXTENSIONS

    for root, dirs, files in os.walk(input_dir):
        dirs[:] = [d for d in dirs if d.lower() not in EXCLUDED_DIRS]
        
        for filename in files:
            if filename.lower() in EXCLUDED_FILENAMES:
                continue
            
            file_path = Path(root) / filename
            if file_path.name.lower() in ALLOWED_FILENAMES or file_path.suffix.lower() in extensions_to_check:
                try:
                    size = file_path.stat().st_size
                    files_with_sizes.append((file_path, size))
                except OSError as e:
                    print(f"--> [Warning] Could not access file stats for '{file_path}': {e}")

    # Sort files by size in descending order
    files_with_sizes.sort(key=lambda item: item[1], reverse=True)
    return files_with_sizes

def create_concatenated_file(input_dir: Path, output_file: Path, files: list[tuple[Path, int]]):
    """Concatenates the content of the provided files into a single output file."""
    print(f"\nüìù Writing {len(files)} files to '{output_file}'...")
    
    try:
        with open(output_file, 'w', encoding='utf-8', errors='ignore') as outfile:
            outfile.write(f"# This file was generated by concatenating all relevant files from the '{input_dir.name}' project folder.\n")
            outfile.write(f"# Total files included: {len(files)}\n\n")

            for file_path, _ in files: # The size is not needed here
                relative_path = file_path.relative_to(input_dir)
                header = f"================================================================================\n"
                header += f"cat {relative_path}\n"
                header += f"================================================================================\n\n"
                outfile.write(header)

                try:
                    content = file_path.read_text(encoding='utf-8')
                    outfile.write(content)
                except Exception as e:
                    error_message = f"--> [Error] Could not read file '{relative_path}': {e}\n"
                    print(error_message, end='')
                    outfile.write(error_message)

                outfile.write("\n\n")
    
    except IOError as e:
        print(f"‚ùå Error: Could not write to output file '{output_file}': {e}")
        sys.exit(1)

def main():
    """Main function to parse arguments and run the script."""
    parser = argparse.ArgumentParser(
        description="Recursively find and concatenate specified text-based files in a directory into a single text file, respecting exclusions.",
        formatter_class=argparse.RawTextHelpFormatter
    )
    parser.add_argument("input_directory", help="The project directory to scan for files.")
    
    filter_group = parser.add_mutually_exclusive_group()
    filter_group.add_argument("--code-only", action="store_true", help="Only include files with code-related extensions.")
    filter_group.add_argument("--py-only", action="store_true", help="Only include Python (.py) files.")
    
    args = parser.parse_args()
    
    input_dir = Path(args.input_directory).resolve()

    if not input_dir.is_dir():
        print(f"‚ùå Error: Input directory '{input_dir}' not found or is not a directory.")
        sys.exit(1)

    output_filename = f"{input_dir.name}.txt"
    output_file = Path(output_filename)

    files_to_process = find_files_to_process(input_dir, args.code_only, args.py_only)

    if not files_to_process:
        print("\nü§∑ No matching files found to concatenate.")
        return

    # --- Print the summary of files to be included ---
    print(f"\nFound {len(files_to_process)} files to include (sorted by size, descending):")
    total_size_bytes = 0
    for file_path, size_bytes in files_to_process:
        relative_path = file_path.relative_to(input_dir)
        formatted_size = format_size(size_bytes)
        print(f"  - {formatted_size.rjust(10)} | {relative_path}")
        total_size_bytes += size_bytes
    
    formatted_total_size = format_size(total_size_bytes)
    print(f"-------------------------------------------")
    print(f"  Total size: {formatted_total_size.rjust(7)}")
    
    create_concatenated_file(input_dir, output_file, files_to_process)
    
    final_output_size_bytes = output_file.stat().st_size
    formatted_output_size = format_size(final_output_size_bytes)
    
    print(f"\n‚úÖ Success! Project content concatenated into '{output_file.resolve()}' (Size: {formatted_output_size}).")

if __name__ == "__main__":
    main()
