import os
import sys
import argparse
from pathlib import Path

# --- Configuration ---
ALLOWED_EXTENSIONS = {
    '.py', '.tsx', '.css', '.js', '.conf', '.json',
    '.html', '.yml', '.yaml', '.txt', '.sh', '.md', '.ini', '.ts'
}
CODE_EXTENSIONS = {
    '.py', '.tsx', '.js', '.ts', '.html', '.css', '.sh',
}
PYTHON_EXTENSIONS = {'.py'}
ALLOWED_FILENAMES = {'dockerfile'}
EXCLUDED_FILENAMES = {'package-lock.json', 'yarn.lock', 'pnpm-lock.yaml', 'gmail_token.json', 'gmail_credentials.json'}
EXCLUDED_DIRS = {
    'node_modules', '.git', 'dist', 'build', 'out',
    '.vscode', '__pycache__', '.idea', '.venv'
}

def format_size(size_bytes: int) -> str:
    """Converts a size in bytes to a human-readable string (KB, MB, GB)."""
    if size_bytes == 0:
        return "0 B"
    power = 1024
    n = 0
    power_labels = {0: 'B', 1: 'KB', 2: 'MB', 3: 'GB', 4: 'TB'}
    while size_bytes >= power and n < len(power_labels) - 1:
        size_bytes /= power
        n += 1
    return f"{size_bytes:.2f} {power_labels[n]}" if n > 0 else f"{int(size_bytes)} {power_labels[n]}"

def find_files_to_process(input_dir: Path, code_only: bool, py_only: bool) -> list[Path]:
    """
    Finds all files in the directory that match the allowlist and are not in the blocklist,
    while skipping excluded directories for performance.
    """
    files_to_process = []
    print(f"üîç Searching for files in '{input_dir}'...")
    print(f"   (Ignoring directories: {', '.join(EXCLUDED_DIRS)})")

    if py_only:
        extensions_to_check = PYTHON_EXTENSIONS
        print("   (Filtering for Python files only)")
    elif code_only:
        extensions_to_check = CODE_EXTENSIONS
        print("   (Filtering for code files only)")
    else:
        extensions_to_check = ALLOWED_EXTENSIONS

    for root, dirs, files in os.walk(input_dir):
        # Exclude specified directories
        dirs[:] = [d for d in dirs if d.lower() not in EXCLUDED_DIRS]
        
        for filename in files:
            if filename.lower() in EXCLUDED_FILENAMES:
                continue
            
            file_path = Path(root) / filename
            # Check for allowed filenames or extensions
            if file_path.name.lower() in ALLOWED_FILENAMES or file_path.suffix.lower() in extensions_to_check:
                files_to_process.append(file_path)

    files_to_process.sort()
    return files_to_process

def create_concatenated_file(input_dir: Path, output_file: Path, files: list[Path]):
    """Concatenates the content of the provided files into a single output file."""
    print(f"üìù Writing {len(files)} files to '{output_file}'...")
    
    try:
        with open(output_file, 'w', encoding='utf-8', errors='ignore') as outfile:
            outfile.write(f"# This file was generated by concatenating all relevant files from the '{input_dir.name}' project folder.\n")
            outfile.write(f"# Total files included: {len(files)}\n\n")

            for file_path in files:
                relative_path = file_path.relative_to(input_dir)
                header = f"================================================================================\n"
                header += f"cat {relative_path}\n"
                header += f"================================================================================\n\n"
                outfile.write(header)

                try:
                    content = file_path.read_text(encoding='utf-8')
                    outfile.write(content)
                except Exception as e:
                    error_message = f"--> [Error] Could not read file '{relative_path}': {e}\n"
                    print(error_message, end='')
                    outfile.write(error_message)

                outfile.write("\n\n")
    
    except IOError as e:
        print(f"‚ùå Error: Could not write to output file '{output_file}': {e}")
        sys.exit(1)

def main():
    """Main function to parse arguments and run the script."""
    parser = argparse.ArgumentParser(
        description="Recursively find and concatenate specified text-based files in a directory into a single text file, respecting exclusions.",
        formatter_class=argparse.RawTextHelpFormatter
    )
    parser.add_argument("input_directory", help="The project directory to scan for files.")
    
    # Add filtering options
    filter_group = parser.add_mutually_exclusive_group()
    filter_group.add_argument("--code-only", action="store_true", help="Only include files with code-related extensions.")
    filter_group.add_argument("--py-only", action="store_true", help="Only include Python (.py) files.")
    
    args = parser.parse_args()
    
    input_dir = Path(args.input_directory).resolve()

    if not input_dir.is_dir():
        print(f"‚ùå Error: Input directory '{input_dir}' not found or is not a directory.")
        sys.exit(1)

    output_filename = f"{input_dir.name}.txt"
    output_file = Path(output_filename)

    files_to_process = find_files_to_process(input_dir, args.code_only, args.py_only)

    if not files_to_process:
        print("ü§∑ No matching files found to concatenate.")
        return

    create_concatenated_file(input_dir, output_file, files_to_process)
    
    # Get the size of the generated file
    final_size_bytes = output_file.stat().st_size
    formatted_size = format_size(final_size_bytes)
    
    print(f"\n‚úÖ Success! Project content concatenated into '{output_file.resolve()}' (Size: {formatted_size}).")

if __name__ == "__main__":
    main()